<!DOCTYPE html><!--

Welcome to Arcora v3!
Build V-AV3.01 - VAPOR build
--
Lyrics powered by Musixmatch
--
NOTICE:
Some lyrics may be inconsistent or delayed. This is an
issue with Musixmatch themselves. Our lyric system is not 
causing these bugs.
--
TO SKIDS:
Why skid this? Why skid a project that took me weeks to 
make? It's very disrespectful. If you want Arcora v3 on
your site, please EMBED IT using <iframe>'s. Please do
not scrape or steal the source code used by Arcora v3.

-->
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Arcora v3</title>
    <link rel="stylesheet" href="/styles/defaults.css" />
    <link rel="stylesheet" href="/styles/theme.css" />

    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    <style>
      :root {
        --color-1: #66699b;
        --color-2: #737691;
        --color-3: #8da5c4;
        --color-4: #b8a6d9;
        --lyrics-color-inactive: rgba(255, 255, 255, 0.3);
        --lyrics-color-active: #ffffff;
        --background-color: #000000;
        --favorite-color: #ffd700;
        --lyrics-offset: 0px;
      }

      html {
        font-size: 2.2vh;
      }

      @media (max-aspect-ratio: 3/2) {
        html {
          font-size: 1.5vw;
        }
      }

      body,
      html {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        background-color: var(--bg);
        font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, Helvetica, Arial, sans-serif;
        color: white;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      #app-container {
        width: calc(100vw - 3rem);
        max-width: calc((100vh - 3rem) * 1.5);
        max-height: calc(100vh - 3rem);
        aspect-ratio: 3 / 2;
        font-size: 1rem;
        position: relative;
        border-radius: 1.5rem;
        overflow: hidden;
        box-shadow: 0 1.25rem 3rem rgba(0, 0, 0, 0.3);
        background-color: var(--background-color);
      }

      .hidden {
        display: none !important;
      }

      #main-screen {
        position: relative;
        width: 100%;
        height: 100%;
      }

      #background-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
        filter: blur(120px) brightness(0.7);
        opacity: 0.5;
        transition: opacity 0.8s ease, filter 0.8s ease;
      }

      .listening-dots {
        animation: blink 1.4s infinite both;
      }
      .listening-dots:nth-child(2) {
        animation-delay: 0.2s;
      }
      .listening-dots:nth-child(3) {
        animation-delay: 0.4s;
      }
      @keyframes blink {
        0%,
        80%,
        100% {
          opacity: 0;
        }
        40% {
          opacity: 1;
        }
      }

      .orb {
        position: absolute;
        width: 120%;
        height: 120%;
        border-radius: 50%;
      }
      #orb1 {
        background-color: var(--color-1);
        top: -60%;
        left: -60%;
        animation: move 10s infinite alternate;
      }
      #orb2 {
        background-color: var(--color-2);
        top: -60%;
        right: -60%;
        animation: move 15s infinite alternate-reverse;
      }
      #orb3 {
        background-color: var(--color-3);
        bottom: -60%;
        left: -60%;
        animation: move 20s infinite alternate;
      }
      #orb4 {
        background-color: var(--color-4);
        bottom: -60%;
        right: -60%;
        animation: move 5s infinite alternate-reverse;
      }
      @keyframes move {
        from {
          transform: translate(0, 0) rotate(0deg) scale(1);
        }
        to {
          transform: translate(10%, 15%) rotate(180deg) scale(1.2);
        }
      }

      #left-panel {
        position: absolute;
        left: 2.5rem;
        top: 0;
        width: calc(45% - 4.25rem);
        height: 100%;
        z-index: 2;
        display: flex;
        flex-direction: column;
        justify-content: center;
        padding: 1.25rem 0;
        box-sizing: border-box;
        transition: opacity 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
      }

      #player-info-top,
      #player-controls-bottom {
        transition: opacity 0.3s cubic-bezier(0.25, 0.8, 0.25, 1),
          transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
      }
      #player-info-top {
        flex: 1 1 auto;
        min-height: 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      #player-controls-bottom {
        flex: 0 0 auto;
      }

      #main-screen.recognition-active #scrub-wrapper,
      #main-screen.recognition-active #controls-container,
      #main-screen.recognition-active #volume-controls,
      #main-screen.recognized-mode #scrub-wrapper,
      #main-screen.recognized-mode #controls-container,
      #main-screen.recognized-mode #volume-controls {
        opacity: 0;
        pointer-events: none;
        max-height: 0;
        margin-bottom: 0 !important;
        overflow: hidden;
      }

      #scrub-wrapper,
      #controls-container,
      #volume-controls {
        transition: opacity 0.3s ease, max-height 0.5s ease,
          margin-bottom 0.5s ease;
        max-height: 6rem;
        will-change: opacity, max-height, margin-bottom;
      }

      #cover-art-container {
        position: relative;
        width: 100%;
        max-width: 25rem;
        margin-left: auto;
        margin-right: auto;
        max-height: 100%;
        aspect-ratio: 1 / 1;
        overflow: hidden;
        border-radius: 0.75rem;
        box-shadow: 0 0.6rem 2rem rgba(0, 0, 0, 0.25);
        background-color: rgba(255, 255, 255, 0.2);
        backdrop-filter: blur(10px);
      }

      #cover-art-display {
        width: 100%;
        height: 100%;
        display: block;
        object-fit: cover;
      }
      #cover-art-display[src="#"] {
        visibility: hidden;
      }

      #song-info-overlay {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        padding: 1.5rem;
        box-sizing: border-box;
        background: linear-gradient(
          to top,
          rgba(0, 0, 0, 0.6) 0%,
          rgba(0, 0, 0, 0) 100%
        );
        pointer-events: none;
      }

      #controls-wrapper {
        max-width: 25rem;
        margin: 0 auto;
      }

      #song-info-overlay .song-title {
        font-size: 1.2em;
        font-weight: 700;
        color: #ffffff;
        margin-bottom: 0.25rem;
      }
      #song-info-overlay .artist-name {
        font-size: 1.2em;
        font-weight: 400;
        color: #b9b9b9;
        margin-bottom: 0;
      }

      #song-info-controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
        margin-top: 1.1rem;
        margin-bottom: 1rem;
      }
      #song-info-controls .text-wrapper {
        min-width: 0;
        flex-shrink: 1;
        transition: opacity 0.5s ease;
      }
      #main-screen.initial-state #song-info-controls .text-wrapper {
        opacity: 0.6;
      }
      #song-info-controls .song-title {
        font-weight: 700;
        color: #ffffff;
        font-size: 1.3em;
        margin-bottom: 0.25rem;
      }
      #song-info-controls .artist-name {
        font-weight: 400;
        color: #a0a0a0;
        font-size: 1.3em;
      }
      #song-info-controls .actions {
        display: flex;
        align-items: center;
        gap: 0.3rem;
        flex-shrink: 0;
      }

      .song-title,
      .artist-name {
        white-space: nowrap;
        overflow: hidden;
      }
      .marquee-wrapper {
        display: inline-block;
        white-space: nowrap;
        animation: marquee var(--duration) linear infinite;
        animation-play-state: paused;
      }
      .marquee-content {
        padding-right: 4em;
      }
      .is-overflowing {
        -webkit-mask-image: linear-gradient(
          to right,
          black 90%,
          transparent 100%
        );
        mask-image: linear-gradient(to right, black 90%, transparent 100%);
      }
      .is-scrolling {
        -webkit-mask-image: linear-gradient(
          90deg,
          transparent,
          black 15%,
          black 85%,
          transparent
        );
        mask-image: linear-gradient(
          90deg,
          transparent,
          black 15%,
          black 85%,
          transparent
        );
      }
      @keyframes marquee {
        from {
          transform: translateX(0);
        }
        to {
          transform: translateX(-50%);
        }
      }

      #favorite-button,
      #search-open-button,
      #recommendations-open-button,
      #recognize-button {
        font-size: 1.1em;
        width: 2.4em;
        height: 2.4em;
        padding: 0;
        border-radius: 50%;
        background-color: rgba(255, 255, 255, 0.1);
        display: flex;
        justify-content: center;
        align-items: center;
        transition: 0.2s ease;
      }

      #song-info-controls .actions .control-button:hover,
      #global-actions .control-button:hover {
        background-color: rgba(255, 255, 255, 0.2);
      }

      #favorite-button.favorited {
        color: var(--favorite-color);
      }

      #favorite-button:disabled,
      #search-open-button:disabled,
      #recommendations-open-button:disabled,
      #recognize-button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }

      #recommendations-open-button.radio-active {
        color: #c561ff;
        animation: pulse 2s infinite;
      }

      @keyframes pulse {
        0% {
          transform: scale(1);
          text-shadow: 0 0 5px rgba(197, 97, 255, 0.5);
        }
        50% {
          transform: scale(1.1);
          text-shadow: 0 0 15px rgba(197, 97, 255, 1);
        }
        100% {
          transform: scale(1);
          text-shadow: 0 0 5px rgba(197, 97, 255, 0.5);
        }
      }

      #recognize-button.active {
        color: #1ed760;
        transform: scale(1.1);
      }

      #scrub-wrapper {
        display: flex;
        align-items: center;
        gap: 1rem;
        width: 100%;
        margin-bottom: 1rem;
      }

      #current-time,
      #duration-time {
        font-size: 0.85em;
        color: #a0a0a0;
        flex-shrink: 0;
        font-family: monospace;
      }

      .slider-bar-container {
        width: 100%;
        height: 0.375rem;
        background-color: rgba(255, 255, 255, 0.3);
        border-radius: 0.2rem;
        position: relative;
      }

      .slider-bar-container.disabled {
        background-color: rgba(255, 255, 255, 0.2);
        pointer-events: none;
      }

      #scrub-bar-container {
        flex-grow: 1;
      }

      .slider-bar-fill {
        height: 100%;
        width: 0%;
        background-color: #ffffff;
        border-radius: 0.2rem;
        position: relative;
        transition: width 0.1s linear;
      }

      .slider-bar-container:not(.disabled) {
        cursor: pointer;
      }

      .slider-handle {
        position: absolute;
        top: 50%;
        right: -0.5rem;
        width: 1rem;
        height: 1rem;
        background-color: white;
        border-radius: 50%;
        transform: translateY(-50%) scale(0);
        transition: transform 0.2s ease;
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
      }

      .slider-bar-container:not(.disabled):hover .slider-handle {
        transform: translateY(-50%) scale(1);
      }

      #volume-controls {
        display: flex;
        align-items: center;
        gap: 1rem;
        margin-bottom: 1.25rem;
      }

      #volume-controls i {
        color: #a0a0a0;
      }

      #controls-container {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 1.25rem;
        margin-bottom: 1.25rem;
      }

      .control-button {
        background: none;
        border: none;
        color: white;
        cursor: pointer;
        font-size: 1.5em;
        opacity: 0.8;
        transition: background-color 0.2s ease, transform 0.28s ease;
      }

      .control-button:hover {
        opacity: 1;
        transform: scale(1.05);
      }

      .control-button:disabled {
        opacity: 0.3;
        cursor: not-allowed;
      }

      .control-button.active {
        opacity: 1;
        transform: scale(1.1);
        text-shadow: 0 0 8px rgba(255, 255, 255, 0.7);
      }

      #play-pause-button-container {
        width: 3em;
        height: 3em;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      #play-pause-button {
        font-size: 3em;
      }

      #prev-track-button {
        font-size: 2.4em;
      }
      #next-track-button {
        font-size: 2.4em;
      }

      #lyrics-container {
        position: absolute;
        left: 45%;
        width: calc(60% - 2.5rem);
        z-index: 2;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        transition: opacity 0.3s cubic-bezier(0.25, 0.8, 0.25, 1),
          transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1),
          filter 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
      }

      .no-lyrics-message {
        font-size: 1.2em;
        color: rgba(255, 255, 255, 0.5);
        text-align: center;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      #lyrics-viewport {
        height: 100%;
        overflow: hidden;
        cursor: grab;
        user-select: none;
        -webkit-user-select: none;
        -webkit-mask-image: linear-gradient(
          to bottom,
          transparent 0%,
          black 15%,
          black 85%,
          transparent 100%
        );
        mask-image: linear-gradient(
          to bottom,
          transparent 0%,
          black 15%,
          black 85%,
          transparent 100%
        );
      }

      #lyrics-viewport:active {
        cursor: grabbing;
      }

      #lyrics-content-wrapper {
        text-align: left;
        transform: translateY(var(--lyrics-offset));
        transition: transform 0.6s cubic-bezier(0.65, 0, 0.35, 1);
      }

      #lyrics-content-wrapper.is-loading {
        height: 100%;
      }

      #lyrics-content-wrapper.manual-scroll {
        transition: none;
      }

      #lyrics-content-wrapper.manual-scroll .line {
        filter: blur(0.5px) !important;
        opacity: 0.8 !important;
        color: var(--lyrics-color-inactive) !important;
      }

      #search-panel,
      #playlist-panel,
      #recommendations-panel {
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        z-index: 5;
        display: flex;
        flex-direction: row;
        padding: 1.25rem 2.5rem;
        box-sizing: border-box;
        opacity: 0;
        transform: scale(1.03);
        transition: opacity 0.3s cubic-bezier(0.25, 0.8, 0.25, 1),
          transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        pointer-events: none;
      }

      .panel-column {
        height: 100%;
        display: flex;
        flex-direction: column;
      }

      .primary-column {
        flex: 0 0 50%;
        padding-right: 1.5rem;
        box-sizing: border-box;
        min-width: 0;
      }

      .details-column {
        flex: 0 0 50%;
        padding-left: 1.5rem;
        box-sizing: border-box;
        border-left: 1px solid rgba(255, 255, 255, 0.1);
        min-width: 0;
      }

      .details-header {
        display: flex;
        align-items: center;
        gap: 1.25rem;
        margin-bottom: 1.5rem;
      }

      .details-header img {
        width: 7.5rem;
        height: 7.5rem;
        border-radius: 0.5rem;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        flex-shrink: 0;
      }

      .details-header-text h2 {
        margin: 0 0 0.3rem 0;
        font-size: 1.8em;
        font-weight: 700;
      }

      .details-header-text p {
        margin: 0;
        color: #b0b0b0;
        font-size: 1.1em;
      }

      .details-section-title,
      .result-section-header {
        font-weight: 700;
        font-size: 1.2em;
        color: #ffffff;
        margin-top: 1.25rem;
        margin-bottom: 1rem;
        padding: 0;
        border: none;
      }

      .panel-results > .details-section-title:first-child,
      .panel-results > .result-section-header:first-child {
        margin-top: 0;
      }

      .panel-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0;
        margin-bottom: 1.25rem;
        flex-shrink: 0;
      }

      .panel-title {
        font-size: 1.8em;
        font-weight: 700;
      }

      .panel-close-button {
        font-size: 1.5em;
      }

      .panel-input {
        width: 100%;
        margin: 0 0 1rem 0;
        background-color: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        color: #e0e0e0;
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 0.5rem;
        font-family: "Inter", sans-serif;
        font-size: 1em;
        box-sizing: border-box;
        outline: none;
        flex-shrink: 0;
        padding: 0.9rem 1rem;
      }

      .panel-input::placeholder {
        color: rgba(255, 255, 255, 0.5);
      }

      .panel-results {
        flex-grow: 1;
        overflow-y: auto;
        padding-right: 0.6rem;
      }

      .panel-results::-webkit-scrollbar {
        width: 6px;
      }

      .panel-results::-webkit-scrollbar-thumb {
        background-color: rgba(255, 255, 255, 0.2);
        border-radius: 3px;
      }

      .result-item {
        display: flex;
        align-items: center;
        gap: 1rem;
        padding: 0.6rem;
        border-radius: 0.5rem;
        cursor: pointer;
        transition: background-color 0.2s;
        border-bottom: none;
        position: relative;
      }

      .result-item:hover {
        background-color: rgba(255, 255, 255, 0.08);
      }

      .result-item img {
        width: 3.1rem;
        height: 3.1rem;
        border-radius: 0.4rem;
        object-fit: cover;
      }

      .result-text {
        flex: 1;
        min-width: 0;
      }

      .result-text h3,
      .result-text p {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .result-text h3 {
        margin: 0 0 0.25rem 0;
        font-size: 1em;
        font-weight: 400;
        color: #fff;
      }

      .result-text p {
        margin: 0;
        font-size: 0.9em;
        color: #a0a0a0;
      }

      .remove-favorite-btn {
        background: none;
        border: none;
        color: #a0a0a0;
        font-size: 1.1em;
        cursor: pointer;
        padding: 0.6rem;
        margin-right: -0.6rem;
        transition: color 0.2s, transform 0.2s;
        flex-shrink: 0;
      }

      .remove-favorite-btn:hover {
        color: #ff5c5c;
        transform: scale(1.1);
      }

      .loading-text,
      .curating-text {
        font-style: italic;
        color: #a0a0a0;
        text-align: center;
        padding: 1.25rem;
        font-size: 1em;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        gap: 0.6rem;
      }

      .sortable-ghost {
        opacity: 0.4;
        background: rgba(255, 255, 255, 0.1);
      }

      #main-screen.panel-active #player-info-top,
      #main-screen.panel-active #player-controls-bottom {
        opacity: 0;
        transform: scale(0.97);
        pointer-events: none;
      }

      #main-screen.panel-active #lyrics-container {
        opacity: 0;
        filter: blur(8px);
        transform: scale(0.97);
        pointer-events: none;
      }

      #main-screen.search-active #search-panel,
      #main-screen.playlist-active #playlist-panel,
      #main-screen.recommendations-active #recommendations-panel {
        opacity: 1;
        transform: scale(1);
        pointer-events: auto;
      }

      .line {
        display: block;
        padding: 0 5rem 0 1.25rem;
        margin-bottom: 2rem;
        font-size: 2.6rem;
        font-weight: 700;
        line-height: 1.2;
        transition: opacity 0.4s, filter 0.4s, color 0.4s, transform 0.4s;
        will-change: filter, opacity, transform;
        letter-spacing: -0.3px;
      }

      .line.past {
        filter: blur(2.6px);
        opacity: 0.35;
        color: var(--lyrics-color-inactive);
      }

      .line.future {
        filter: blur(1.8px);
        opacity: 0.35;
        color: var(--lyrics-color-inactive);
      }

      .line.active {
        filter: blur(0);
        opacity: 1;
        color: var(--lyrics-color-active);
      }

      .word {
        background: linear-gradient(
          to right,
          var(--lyrics-color-active) 0%,
          var(--lyrics-color-active) 45%,
          var(--lyrics-color-inactive) 55%,
          var(--lyrics-color-inactive) 100%
        );
        background-size: 210% 100%;
        background-position: 100% 0;
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
        transition: background-position 0.25s ease-out, transform 0.2s ease-out;
        display: inline-block;
      }

      .line.line--simple .word {
        background: none;
        -webkit-background-clip: unset;
        background-clip: unset;
        color: inherit;
      }

      #player-container,
      #album-art{
        position: fixed;
        top: -1000px;
        left: -1000px;
        width: 1px;
        height: 1px;
        opacity: 1;
      }

      #view-toggle-button {
        display: none;
        position: absolute;
        bottom: 1.5rem;
        left: 50%;
        transform: translateX(-50%);
        z-index: 101;
        background-color: rgba(20, 20, 20, 0.8);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: white;
        width: 3.75rem;
        height: 3.75rem;
        border-radius: 50%;
        font-size: 1.5em;
        cursor: pointer;
      }

      #recognize-button {
        display: none;
      }

      .recommendations-menu-item {
        display: flex;
        align-items: center;
        gap: 1.25rem;
        padding: 1rem 0.6rem;
        border-radius: 0.5rem;
        cursor: pointer;
        transition: background-color 0.2s;
      }
      .recommendations-menu-item:hover {
        background-color: rgba(255, 255, 255, 0.08);
      }
      .recommendations-menu-item.disabled {
        opacity: 0.4;
        cursor: not-allowed;
        pointer-events: none;
      }
      .recommendations-menu-item .icon {
        font-size: 1.5em;
        width: 1.5em;
        text-align: center;
        color: #a0a0a0;
      }
      .recommendations-menu-item .text-content h3 {
        margin: 0 0 0.25rem 0;
        font-size: 1.1em;
        font-weight: 700;
      }
      .recommendations-menu-item .text-content p {
        margin: 0;
        font-size: 0.9em;
        color: #888;
      }
      .recommendations-context-header {
        font-size: 0.9em;
        font-weight: 700;
        color: #a0a0a0;
        text-transform: uppercase;
        margin-top: 1.5rem;
        margin-bottom: 0.6rem;
        padding: 0 0.6rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .radio-active-view,
      .daily-discover-header {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        padding: 1.25rem;
        box-sizing: border-box;
      }
      .daily-discover-header {
        padding: 0 0 1rem 0;
        justify-content: space-between;
        flex-direction: row;
        width: 100%;
      }
      .daily-discover-header h4 {
        margin: 0;
      }
      .radio-active-view h2 {
        font-size: 1.8em;
        margin-bottom: 0.3rem;
      }
      .radio-active-view p {
        color: #a0a0a0;
        margin-bottom: 1.5rem;
      }
      .stop-radio-button,
      .refresh-discover-button {
        background-color: #c561ff;
        color: white;
        border: none;
        border-radius: 50px;
        padding: 1rem 2rem;
        font-size: 1.1em;
        font-weight: 700;
        cursor: pointer;
        transition: transform 0.2s, background-color 0.2s;
      }
      .refresh-discover-button {
        font-size: 0.8em;
        padding: 0.5rem 1rem;
        background-color: rgba(255, 255, 255, 0.1);
      }
      .stop-radio-button:hover,
      .refresh-discover-button:hover {
        transform: scale(1.05);
        background-color: #d17cff;
      }
      .refresh-discover-button:hover {
        background-color: rgba(255, 255, 255, 0.2);
      }

      .line.instrumental-line {
        text-align: left;
        font-size: 2.6rem;
        opacity: 0;
        margin-bottom: 2rem;
        padding: 0 5rem 0 1.25rem;
        transition: opacity 0.2s ease-out;
      }

      .line.instrumental-line.active {
        opacity: 0.8;
        transition: opacity 0.5s ease-in;
      }

      .line.instrumental-line i {
        animation: spin 3s linear infinite;
      }

      @keyframes spin {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }

      @keyframes longWordPulse {
        0%,
        100% {
          transform: scale(1) translateY(0px);
        }
        50% {
          transform: scale(1.05) translateY(-3.5px);
        }
      }

      #global-actions {
        position: absolute;
        top: 1.75rem;
        right: 3rem;
        z-index: 10;
        display: flex;
        gap: 0.5rem;
      }
    </style>
  </head>
  <body>
    <div id="app-container">
      <div id="main-screen">
        <div id="background-canvas">
          <div class="orb" id="orb1"></div>
          <div class="orb" id="orb2"></div>
          <div class="orb" id="orb3"></div>
          <div class="orb" id="orb4"></div>
        </div>

        <div id="left-panel">
          <div id="player-info-top">
            <div id="cover-art-container">
              <img id="cover-art-display" src="#" alt="Album Cover" />
              <div id="song-info-overlay">
                <div class="song-title">Not Playing</div>
                <div class="artist-name">Search to start playing</div>
              </div>
            </div>
          </div>

          <div id="player-controls-bottom">
            <div id="controls-wrapper">
              <div id="song-info-controls" class="hidden">
                <div class="text-wrapper">
                  <div class="song-title">Not Playing</div>
                  <div class="artist-name">Search to start playing</div>
                </div>
                <div class="actions">
                  <button
                    id="recognize-button"
                    class="control-button"
                    title="Identify songs using your microphone."
                  >
                    <i class="fa-solid fa-microphone-lines"></i>
                  </button>
                  <button
                    id="favorite-button"
                    class="control-button"
                    title="Favorite the playing song"
                    disabled
                  >
                    <i class="fa-regular fa-star"></i>
                  </button>
                </div>
              </div>
              <div id="scrub-wrapper">
                <span id="current-time">-:--</span>
                <div
                  id="scrub-bar-container"
                  class="slider-bar-container disabled"
                >
                  <div id="scrub-bar-fill" class="slider-bar-fill">
                    <div class="slider-handle"></div>
                  </div>
                </div>
                <span id="duration-time">-:--</span>
              </div>
              <div id="controls-container">
                <button
                  id="repeat-button"
                  class="control-button"
                  title="Repeat"
                >
                  <i class="fa-solid fa-repeat"></i>
                </button>
                <button
                  id="prev-track-button"
                  class="control-button"
                  title="Previous"
                >
                  <i class="fa-solid fa-backward"></i>
                </button>
                <div id="play-pause-button-container">
                  <button
                    id="play-pause-button"
                    class="control-button"
                    title="Play/Pause"
                  >
                    <i id="play-pause-icon" class="fa-solid fa-play"></i>
                  </button>
                </div>
                <button
                  id="next-track-button"
                  class="control-button"
                  title="Next"
                >
                  <i class="fa-solid fa-forward"></i>
                </button>
                <button
                  id="playlist-button"
                  class="control-button"
                  title="View starred songs"
                >
                  <i class="fa-solid fa-list-ul"></i>
                </button>
              </div>
              <div id="volume-controls">
                <i class="fa-solid fa-volume-off"></i>
                <div
                  id="volume-bar-container"
                  class="slider-bar-container disabled"
                >
                  <div id="volume-bar-fill" class="slider-bar-fill">
                    <div class="slider-handle"></div>
                  </div>
                </div>
                <i class="fa-solid fa-volume-high"></i>
              </div>
            </div>
          </div>
        </div>

        <div id="lyrics-container">
          <div id="global-actions">
            <button
              id="recommendations-open-button"
              class="control-button"
              title="Recommendations"
            >
              <i class="fa-solid fa-wand-magic-sparkles"></i>
            </button>
            <button
              id="search-open-button"
              class="control-button"
              title="Search for songs"
            >
              <i class="fa-solid fa-magnifying-glass"></i>
            </button>
          </div>

          <div id="lyrics-viewport">
            <div id="lyrics-content-wrapper"></div>
          </div>
        </div>

        <div id="search-panel">
          <div class="primary-column panel-column">
            <div class="panel-header">
              <span class="panel-title">Search</span>
              <button
                id="search-close-button"
                class="control-button panel-close-button"
              >
                <i class="fa-solid fa-xmark"></i>
              </button>
            </div>
            <input
              type="text"
              id="search-input"
              class="panel-input"
              placeholder="Search tracks, artists, albums..."
              autocomplete="off"
            />
            <div id="search-results" class="panel-results"></div>
          </div>
          <div class="details-column panel-column">
            <div id="search-details-view" class="panel-results"></div>
          </div>
        </div>

        <div id="playlist-panel">
          <div class="primary-column panel-column">
            <div class="panel-header">
              <span class="panel-title">Favorites</span>
              <button
                id="playlist-close-button"
                class="control-button panel-close-button"
              >
                <i class="fa-solid fa-xmark"></i>
              </button>
            </div>
            <input
              type="text"
              id="playlist-search-input"
              class="panel-input"
              placeholder="Search favorites..."
              autocomplete="off"
            />
            <div id="playlist-results" class="panel-results"></div>
          </div>
          <div class="details-column panel-column"></div>
        </div>

        <div id="recommendations-panel">
          <div class="primary-column panel-column">
            <div class="panel-header">
              <span class="panel-title">Recommendations</span>
              <button
                id="recommendations-close-button"
                class="control-button panel-close-button"
              >
                <i class="fa-solid fa-xmark"></i>
              </button>
            </div>
            <div id="recommendations-menu" class="panel-results"></div>
          </div>
          <div class="details-column panel-column">
            <div id="recommendations-details-view" class="panel-results"></div>
          </div>
        </div>

        <div id="player-container"></div>
        <img id="album-art" crossorigin="anonymous" />
      </div>

      <button id="view-toggle-button">
        <i id="view-toggle-icon" class="fa-solid fa-music"></i>
      </button>
    </div>
    <script>
      const mainScreen = document.getElementById("main-screen");

      const lyricsContentWrapper = document.getElementById(
        "lyrics-content-wrapper"
      );

      const lyricsViewport = document.getElementById("lyrics-viewport");
      const albumArt = document.getElementById("album-art");
      const coverArtContainer = document.getElementById("cover-art-container");
      const coverArtDisplay = document.getElementById("cover-art-display");
      const scrubBarContainer = document.getElementById("scrub-bar-container");
      const scrubBarFill = document.getElementById("scrub-bar-fill");
      const playPauseButton = document.getElementById("play-pause-button");
      const playPauseIcon = document.getElementById("play-pause-icon");
      const repeatButton = document.getElementById("repeat-button");
      const volumeBarContainer = document.getElementById(
        "volume-bar-container"
      );
      const volumeBarFill = document.getElementById("volume-bar-fill");
      const viewToggleButton = document.getElementById("view-toggle-button");
      const viewToggleIcon = document.getElementById("view-toggle-icon");
      const currentTimeEl = document.getElementById("current-time");
      const durationTimeEl = document.getElementById("duration-time");
      const songInfoOverlay = document.getElementById("song-info-overlay");
      const songInfoControls = document.getElementById("song-info-controls");
      const allSongTitles = [
        songInfoOverlay.querySelector(".song-title"),
        songInfoControls.querySelector(".song-title"),
      ];
      const allArtistNames = [
        songInfoOverlay.querySelector(".artist-name"),
        songInfoControls.querySelector(".artist-name"),
      ];
      const searchPanel = document.getElementById("search-panel");
      const searchOpenButton = document.getElementById("search-open-button");
      const searchCloseButton = document.getElementById("search-close-button");
      const searchInput = document.getElementById("search-input");
      const searchResultsContainer = document.getElementById("search-results");
      const playlistPanel = document.getElementById("playlist-panel");
      const playlistButton = document.getElementById("playlist-button");
      const playlistCloseButton = document.getElementById(
        "playlist-close-button"
      );
      const playlistSearchInput = document.getElementById(
        "playlist-search-input"
      );
      const playlistResultsContainer =
        document.getElementById("playlist-results");
      const favoriteButton = document.getElementById("favorite-button");
      const recommendationsOpenButton = document.getElementById(
        "recommendations-open-button"
      );
      const recommendationsPanel = document.getElementById(
        "recommendations-panel"
      );
      const recommendationsCloseButton = document.getElementById(
        "recommendations-close-button"
      );
      const recommendationsMenu = document.getElementById(
        "recommendations-menu"
      );
      const recommendationsDetailsView = document.getElementById(
        "recommendations-details-view"
      );
      const recognizeButton = document.getElementById("recognize-button");
      const nextTrackButton = document.getElementById("next-track-button");
      const prevTrackButton = document.getElementById("prev-track-button");

      const searchDetailsView = document.getElementById("search-details-view");
      const GROUP_RESULTS = true;

      let lyrics = [],
        currentRawLRC = null,
        currentLineIndex = -1,
        player,
        animationFrameId;

      let isManuallyScrolling = false,
        scrollTimeout,
        lastScrolledIndex = -1,
        touchStartY = 0,
        initialTouchOffset = 0;

      let isRepeating = false,
        isPlaying = false,
        durationSet = false;
      let currentTrackData = null;
      let activeMarquees = [];
      let playbackQueue = [];
      let queueIndex = -1;

      let isRadioActive = false,
        radioSeedArtist = null,
        nextSongIsPreloaded = false;

      let isRecognizing = false;
      let recognitionWorker;
      let recognitionAudioContext,
        recognitionStream,
        recognitionScriptProcessor,
        recognitionSource;
      let recognitionTimeouts = [];
      let recognitionStartTime = null;
      let songStartTime = null;
      let isRecognitionSyncActive = false;

      const playerInterface = {
        youtube: {
          create: (videoId, onStateChange, onReady) =>
            new YT.Player("player-container", {
              videoId,
              host: "https://www.youtube-nocookie.com",
              playerVars: { autoplay: 1, controls: 0, modestbranding: 1 },
              events: { onReady, onStateChange },
            }),
          play: () => player.playVideo(),
          pause: () => player.pauseVideo(),
          getCurrentTime: () => (player ? player.getCurrentTime() : 0),
          getDuration: () => (player ? player.getDuration() : 0),
          seekTo: (time) => player.seekTo(time, true),
          setVolume: (level) => player.setVolume(level * 100),
        },
      };

      let isPlayerReady = false;
      let queuedTrack = null;

      // This function now contains the critical 'playsinline' and 'origin' parameters from v2.
function initializePlayer(videoId) {
  if (player) {
    return; 
  }
  console.log("First user click: Initializing player with video ID:", videoId);
  player = new YT.Player("player-container", {
    height: "190",
    width: "320",
    videoId: videoId,
    playerVars: {
      // These parameters are copied directly from the working Arcora v2
      playsinline: 1,
      origin: window.location.origin,
      enablejsapi: 1,
      rel: 0,
      modestbranding: 1,
      controls: 0,
      autoplay: 1 // Autoplay is safe here because we are inside a user click
    },
    events: {
      onReady: onPlayerReady,
      onStateChange: onPlayerStateChange,
    },
  });
}


      let isYouTubeApiReady = false; 
window.onYouTubeIframeAPIReady = function () {
  console.log("YouTube IFrame API is ready.");
  isYouTubeApiReady = true;
};

      async function loadTrack(trackData, queue = [], index = -1) {
        if (mainScreen.classList.contains("panel-active")) {
          mainScreen.classList.remove(
            "panel-active",
            "search-active",
            "playlist-active",
            "recommendations-active"
          );
        }

        nextSongIsPreloaded = false;
        playbackQueue = queue;
        queueIndex = index;
        updateQueueControls();

        resetToInitialState(true);
        mainScreen.classList.remove("initial-state");

        resetMarquees();
        allSongTitles.forEach((el) => (el.textContent = trackData.trackName));
        allArtistNames.forEach((el) => (el.textContent = trackData.artistName));
        setupMarquees();
        const largeArt =
          trackData.artworkUrl1000 ||
          trackData.artworkUrl100?.replace("100x100", "600x600");
        coverArtDisplay.src = largeArt;
        albumArt.src = `https://wsrv.nl/?url=${encodeURIComponent(largeArt)}`;
        albumArt.onload = () => {
          extractColors(albumArt);
          updateTextPlacement();
        };

        if (trackData.rawLRC) {
          initializeLyrics(parseLRC(trackData.rawLRC), true);
        } else {
          fetchAndDisplayLyrics(
            trackData.trackName,
            trackData.artistName,
            true
          );
        }

        try {
          if (!trackData.videoId) {
            const videoData = await fetch(
              `https://vapor.my/api/yt?query=${encodeURIComponent(
                `${trackData.trackName} - ${trackData.artistName} "topic"`
              )}`
            ).then((res) => res.json());
            trackData.videoId = videoData.video_id;
          }

          if (!trackData.videoId)
            throw new Error("Could not find a playable video.");
          currentTrackData = { ...trackData };
          updateFavoriteButtonState();
          favoriteButton.disabled = false;

if (player) {
  console.log("Player exists. Loading video:", trackData.videoId);
  player.loadVideoById(trackData.videoId);
} else if (isYouTubeApiReady) {
  initializePlayer(trackData.videoId);
} else {
  console.log("API not ready yet. Queuing track.");
  queuedTrack = { trackData, queue, index };
}
        } catch (error) {
          console.error("Failed to load track data:", error);
          lyricsContentWrapper.innerHTML = `<div class="no-lyrics-message">Error loading song.</div>`;
          currentTrackData = null;
          favoriteButton.disabled = true;
          updateFavoriteButtonState();
        }
      }

      function playNextTrack() {
        if (playbackQueue.length > 0) {
          let nextIndex = queueIndex + 1;
          if (nextIndex >= playbackQueue.length) {
            if (isRepeating) {
              nextIndex = 0;
            } else {
              if (isRadioActive) {
                console.log("Radio queue ended, fetching more songs...");
                startRadioMode(currentTrackData, false);
                return;
              }
              resetToInitialState();
              return;
            }
          }
          loadTrack(playbackQueue[nextIndex], playbackQueue, nextIndex);
        } else if (isRepeating && currentTrackData) {
          loadTrack(currentTrackData);
        }
      }

      function onPlayerReady(event) {
        console.log("Persistent player is ready to receive commands.");
        isPlayerReady = true;
        const initialVolume = 0.75;
        playerInterface.youtube.setVolume(initialVolume);
        volumeBarFill.style.width = `${initialVolume * 100}%`;

        if (queuedTrack) {
          console.log("Loading queued track.");
          loadTrack(
            queuedTrack.trackData,
            queuedTrack.queue,
            queuedTrack.index
          );
          queuedTrack = null;
        }
      }

      function onPlayerStateChange(event) {
        const state = event.data;

        if (state === YT.PlayerState.PLAYING) {
          isPlaying = true;
          playPauseIcon.classList.replace("fa-play", "fa-pause");

          if (!animationFrameId) {
            animationFrameId = requestAnimationFrame(masterUpdateLoop);
          }
        } else {
          isPlaying = false;
          playPauseIcon.classList.replace("fa-pause", "fa-play");
        }

        if (state === YT.PlayerState.ENDED) {
          playNextTrack();
        }
      }

      async function preloadTrack(track) {
        try {
          if (!track || nextSongIsPreloaded) return;
          console.log("Preloading next track:", track.trackName);
          nextSongIsPreloaded = true;

          const preloadPromises = [];

          if (!track.videoId) {
            preloadPromises.push(
              fetch(
                `https://vapor.my/api/yt?query=${encodeURIComponent(
                  `${track.trackName} - ${track.artistName} "topic"`
                )}`
              )
                .then((res) => res.json())
                .then((data) => {
                  track.videoId = data.video_id;
                })
            );
          }

          if (!track.rawLRC) {
            preloadPromises.push(
              fetch(
                `https://vapor.my/api/mxlyric?s=${encodeURIComponent(
                  track.trackName
                )}&a=${encodeURIComponent(track.artistName)}`
              )
                .then((res) => res.text())
                .then((text) => {
                  if (!text.includes("START BUILDING ON RENDER TODAY")) {
                    const lyricData = JSON.parse(text);
                    track.rawLRC = lyricData.lyrics;
                  }
                })
            );
          }

          await Promise.all(preloadPromises);
          console.log("Preloading complete for:", track.trackName);
        } catch (error) {
          console.error("Failed to preload track:", error);
        }
      }

      function unifiedLyricsUpdater(currentTimeMs) {
        const MAX_LIFT_HEIGHT = 2;

        if (!lyrics || lyrics.length === 0) return;

        const scrollAnticipation = 200;
        const effectiveTime = currentTimeMs + scrollAnticipation;
        let upcomingLineIndex = lyrics.findIndex((line, i) => {
          const nextLine = lyrics[i + 1];
          return (
            effectiveTime >= line.start &&
            (nextLine ? effectiveTime < nextLine.start : true)
          );
        });
        if (
          upcomingLineIndex > -1 &&
          upcomingLineIndex !== lastScrolledIndex &&
          !isManuallyScrolling
        ) {
          const upcomingLineEl = lyrics[upcomingLineIndex]?.dom;
          if (upcomingLineEl) {
            const viewportHeight = lyricsViewport.clientHeight;
            const y = -(
              upcomingLineEl.offsetTop -
              viewportHeight / 2 +
              upcomingLineEl.offsetHeight / 2
            );
            document.documentElement.style.setProperty(
              "--lyrics-offset",
              `${y}px`
            );
            lastScrolledIndex = upcomingLineIndex;
          }
        }
        let newIndex = lyrics.findIndex((line, i) => {
          const nextLine = lyrics[i + 1];
          return (
            currentTimeMs >= line.start &&
            (nextLine ? currentTimeMs < nextLine.start : true)
          );
        });

        if (newIndex !== currentLineIndex) {
          const oldLine = lyrics[currentLineIndex];
          if (oldLine && oldLine.isEnhanced) {
            oldLine.words.forEach((word) => {
              if (word.dom) {
                const style = word.dom.style;
                style.backgroundPosition = "100% 0";
                style.textShadow = "";
                style.transform = "";
                style.animation = "";
                word.animationHasPlayed = false;
              }
            });
          }

          lyrics.forEach((line, i) => {
            line.dom?.classList.toggle("past", i < newIndex);
            line.dom?.classList.toggle("active", i === newIndex);
            line.dom?.classList.toggle("future", i > newIndex);
          });
          currentLineIndex = newIndex;
        }

        if (currentLineIndex > -1 && lyrics[currentLineIndex]?.isEnhanced) {
          lyrics[currentLineIndex].words.forEach((word) => {
            if (!word.dom) return;

            const { start, end } = word;
            const duration = end - start;
            const style = word.dom.style;
            const isActive = currentTimeMs >= start && currentTimeMs < end;

            let progress = 0;
            if (currentTimeMs >= end) {
              progress = 1;
            } else if (isActive) {
              progress = Math.min((currentTimeMs - start) / duration, 1);
            }

            style.backgroundPosition = `${100 - progress * 100}% 0`;

            const subtleMaxBlur = 4.5;
            const subtleMaxOpacity = 0.5;
            const intenseMaxBlur = 10;
            const intenseMaxOpacity = 0.7;

            let finalBlur = progress * subtleMaxBlur;
            let finalOpacity = progress * subtleMaxOpacity;

            if (word.isLong) {
              if (isActive) {
                if (!word.animationHasPlayed) {
                  word.dom.style.animation = `longWordPulse ${
                    duration / 1000
                  }s ease-in-out`;
                  word.animationHasPlayed = true;
                }
                const pulseProgress = 1 - Math.abs(progress - 0.5) * 2;
                finalBlur += pulseProgress * (intenseMaxBlur - subtleMaxBlur);
                finalOpacity +=
                  pulseProgress * (intenseMaxOpacity - subtleMaxOpacity);
              } else if (word.animationHasPlayed) {
                word.dom.style.animation = "";
                word.animationHasPlayed = false;
              }
            } else {
              const lift = progress * -MAX_LIFT_HEIGHT;
              style.transform = `translateY(${lift}px)`;
            }

            style.textShadow = `0 0 ${finalBlur}px rgba(255, 255, 255, ${finalOpacity})`;
          });
        }
      }
      function masterUpdateLoop() {
        let currentTimeMs = 0;
        let shouldContinueLoop = false;

        if (isPlaying && player && typeof player.getDuration === "function") {
          shouldContinueLoop = true;
          const currentTime = playerInterface.youtube.getCurrentTime();
          currentTimeMs = currentTime * 1000;
          const videoDuration = playerInterface.youtube.getDuration();

          if (videoDuration > 0) {
            scrubBarFill.style.width = `${
              (currentTime / videoDuration) * 100
            }%`;
            currentTimeEl.textContent = formatTime(currentTime);
            if (!durationSet) {
              durationTimeEl.textContent = formatTime(videoDuration);
              durationSet = true;
            }

            if (
              videoDuration - currentTime < 15 &&
              queueIndex < playbackQueue.length - 1
            ) {
              preloadTrack(playbackQueue[queueIndex + 1]);
            }
          }
        } else if (isRecognitionSyncActive) {
          shouldContinueLoop = true;
          currentTimeMs = Date.now() - songStartTime;
        }

        if (shouldContinueLoop) {
          unifiedLyricsUpdater(currentTimeMs);
          animationFrameId = requestAnimationFrame(masterUpdateLoop);
        } else {
          animationFrameId = null;
        }
      }

      function startLyricSync() {
        stopLyricSync();
        if (!songStartTime || !lyrics || lyrics.length === 0) return;
        isRecognitionSyncActive = true;
        if (!animationFrameId) {
          animationFrameId = requestAnimationFrame(masterUpdateLoop);
        }
      }

      function stopLyricSync() {
        isRecognitionSyncActive = false;
        if (!isPlaying && animationFrameId) {
          cancelAnimationFrame(animationFrameId);
          animationFrameId = null;
        }
      }

      function initializeWorker() {
        if (recognitionWorker) {
          recognitionWorker.terminate();
          recognitionWorker = null;
        }
        recognitionWorker = new Worker("fingerprint-worker.js");
        recognitionWorker.onmessage = (event) => {
          if (!isRecognizing) return;
          if (
            event.data.type === "fingerprint-ready" ||
            event.data.type === "sigready"
          ) {
            setRecognitionStatus("Matching");
            const fingerprint =
              event.data.fingerprint ||
              arrayBufferToBase64(event.data.signatureArray.buffer);
            sendApiRequest(fingerprint);
          } else if (event.data.type === "error") {
            console.error("Worker error:", event.data.error);
            setRecognitionStatus(`Worker Error`, true);
            stopRecognition();
          }
        };
        recognitionWorker.onerror = (error) => {
          console.error("Critical worker error:", error);
          setRecognitionStatus("A critical error occurred.", true);
          stopRecognition();
        };
      }

      function resetPlayerForRecognition() {
        if (player && isPlaying) playerInterface.youtube.pause();
        mainScreen.classList.add("recognition-active");
        mainScreen.classList.remove("initial-state", "recognized-mode");
        coverArtDisplay.src = "#";
        lyricsContentWrapper.innerHTML = "";
        resetMarquees();
        allSongTitles.forEach((el) => (el.textContent = "Capturing"));
        allArtistNames.forEach(
          (el) =>
            (el.innerHTML = `this song<span class="listening-dots">.</span><span class="listening-dots">.</span><span class="listening-dots">.</span>`)
        );
        favoriteButton.disabled = true;
        updateFavoriteButtonState();
      }

      function setRecognitionStatus(title, isError = false) {
        if (!isRecognizing && !isError) return;
        allSongTitles.forEach((el) => (el.textContent = title));
        if (isError)
          allArtistNames.forEach(
            (el) => (el.textContent = "Please try again.")
          );
      }

      function startRecognition() {
        if (isRecognizing) return;
        isRecognizing = true;

        resetToInitialState();
        resetPlayerForRecognition();
        initializeWorker();
        recognizeButton.classList.add("active");
        recognizeButton.disabled = true;

        navigator.mediaDevices
          .getUserMedia({ audio: true })
          .then((stream) => {
            recognitionStartTime = Date.now();

            recognitionStream = stream;
            recognitionAudioContext = new AudioContext();
            recognitionSource =
              recognitionAudioContext.createMediaStreamSource(stream);
            recognitionScriptProcessor =
              recognitionAudioContext.createScriptProcessor(4096, 1, 1);
            const audioBuffer = [];
            let recLength = 0;
            recognitionScriptProcessor.onaudioprocess = (event) => {
              if (!isRecognizing) return;
              const inputData = event.inputBuffer.getChannelData(0);
              const bufferCopy = new Float32Array(inputData);
              audioBuffer.push(bufferCopy);
              recLength += bufferCopy.length;
            };
            recognitionSource.connect(recognitionScriptProcessor);
            recognitionScriptProcessor.connect(
              recognitionAudioContext.destination
            );
            const timeoutId = setTimeout(() => {
              if (!isRecognizing) return;
              setRecognitionStatus("Analyzing");
              const mergedBuffer = mergeBuffers(audioBuffer, recLength);
              recognitionWorker.postMessage({
                type: "getSigX",
                audioF32: mergedBuffer,
                index: 0,
                sampleRate: recognitionAudioContext.sampleRate,
              });
            }, 5000);
            recognitionTimeouts.push(timeoutId);
            stream.oninactive = () => {
              stopRecognition();
            };
          })
          .catch((err) => {
            console.error("Microphone Access Error:", err);
            setRecognitionStatus("Microphone access denied.", true);
            stopRecognition();
          });
      }

      function stopRecognition() {
        if (!isRecognizing) return;
        isRecognizing = false;
        recognitionTimeouts.forEach(clearTimeout);
        recognitionTimeouts.length = 0;
        if (recognitionScriptProcessor) recognitionScriptProcessor.disconnect();
        if (recognitionSource) recognitionSource.disconnect();
        if (recognitionStream)
          recognitionStream.getTracks().forEach((track) => track.stop());
        if (recognitionAudioContext) recognitionAudioContext.close();
        recognizeButton.classList.remove("active");
        recognizeButton.disabled = false;
      }

      async function sendApiRequest(fingerprint) {
        try {
          const response = await fetch("https://example.com", {
            // yeah this isnt out yet
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              data: fingerprint,
              sessionId: generateUUID(),
              lang: "en",
              country: "US",
            }),
          });
          if (!response.ok) throw new Error(`API Error: ${response.status}`);
          const result = await response.json();
          if (result?.results?.matches?.length > 0) {
            displayRecognitionResult(result.results.matches[0]);
          } else {
            setRecognitionStatus("No match found.", true);
            mainScreen.classList.remove("recognition-active");
          }
        } catch (error) {
          console.error("API Request Failed:", error);
          setRecognitionStatus("Request failed.", true);
          mainScreen.classList.remove("recognition-active");
        } finally {
          stopRecognition();
        }
      }

      async function displayRecognitionResult(match) {
        mainScreen.classList.remove("recognition-active");
        mainScreen.classList.add("recognized-mode");
        const track = match.attributes;
        const trackData = {
          trackName: track.title,
          artistName: track.primaryArtist,
          artworkUrl100: track.images?.coverArtHq || track.images?.coverart,
          trackId: match.trackId,
        };
        currentTrackData = trackData;
        favoriteButton.disabled = !trackData.trackId;
        updateFavoriteButtonState();
        resetMarquees();
        allSongTitles.forEach((el) => (el.textContent = trackData.trackName));
        allArtistNames.forEach((el) => (el.textContent = trackData.artistName));
        setupMarquees();
        const largeArt = trackData.artworkUrl100.replace("100x100", "600x600");
        coverArtDisplay.src = largeArt;
        albumArt.src = `https://wsrv.nl/?url=${encodeURIComponent(largeArt)}`;
        albumArt.onload = () => {
          extractColors(albumArt);
          updateTextPlacement();
        };

        searchOpenButton.disabled = true;
        recognizeButton
          .querySelector("i")
          .classList.replace("fa-microphone-lines", "fa-xmark");
        recognizeButton.disabled = false;

        let calculatedSongStartTime = null;

        if (match.attributes && match.attributes.webUrl) {
          const offsetMatch = match.attributes.webUrl.match(
            /offsetInMilliseconds=(\d+)/
          );
          if (offsetMatch && offsetMatch[1]) {
            const offsetMs = parseInt(offsetMatch[1], 10);
            calculatedSongStartTime = recognitionStartTime - offsetMs;
          } else {
            console.error("ERROR: offsetInMilliseconds not found in webUrl.");
          }
        } else {
          console.error("ERROR: webUrl not found in api response attributes.");
        }

        fetchAndDisplayLyrics(
          trackData.trackName,
          trackData.artistName,
          false,
          calculatedSongStartTime
        );
      }

      async function fetchAndDisplayLyrics(
        trackName,
        artistName,
        allowSeeking,
        startTime = null
      ) {
        showLoader(lyricsContentWrapper);
        lyricsContentWrapper.classList.add("is-loading");
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 8000);

        try {
          const apiUrl = `https://vapor.my/api/mxlyric?s=${encodeURIComponent(
            trackName
          )}&a=${encodeURIComponent(artistName)}`;

          const response = await fetch(apiUrl, { signal: controller.signal });
          clearTimeout(timeoutId);

          const lyricData = await response.json();

          if (response.ok && lyricData && lyricData.lyrics) {
            currentRawLRC = lyricData.lyrics;
            const parsed = parseLRC(lyricData.lyrics);
            lyrics = parsed;

            initializeLyrics(parsed, allowSeeking);

            if (startTime) {
              songStartTime = startTime;
              startLyricSync();
            }
            return true;
          } else {
            throw new Error(lyricData.error || "Failed to fetch lyrics.");
          }
        } catch (e) {
          lyrics = [];
          currentRawLRC = null;
          console.error("Lyric fetch error:", e.message);
          lyricsContentWrapper.innerHTML = `<div class="no-lyrics-message"></div>`;
          return false;
        } finally {
          lyricsContentWrapper.classList.remove("is-loading");
        }
      }

      function resetToInitialState(keepPanels = false) {
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
        isPlaying = false;
        durationSet = false;

        if (!keepPanels) {
          playbackQueue = [];
          queueIndex = -1;
          updateQueueControls();
          if (isRadioActive) stopRadioMode(false);
        }

        scrubBarFill.style.width = "0%";
        currentTimeEl.textContent = "0:00";
        durationTimeEl.textContent = "0:00";
        playPauseIcon.classList.replace("fa-pause", "fa-play");
        document.documentElement.style.setProperty("--lyrics-offset", "0px");
        isManuallyScrolling = false;
        lastScrolledIndex = -1;
        currentLineIndex = -1;
        stopLyricSync();

        mainScreen.classList.remove("recognition-active", "recognized-mode");
        coverArtDisplay.src = "#";
        lyricsContentWrapper.innerHTML = "";
        lyrics = [];
        currentRawLRC = null;
        resetMarquees();
        allSongTitles.forEach((el) => (el.textContent = "Not Playing"));
        allArtistNames.forEach(
          (el) => (el.textContent = "Search to start playing")
        );
        currentTrackData = null;
        favoriteButton.disabled = true;
        updateFavoriteButtonState();
        searchOpenButton.disabled = false;
        recognizeButton
          .querySelector("i")
          .classList.replace("fa-xmark", "fa-microphone-lines");
      }

      function showLoader(container) {
        container.innerHTML = `<div class="loading-text"><i>Loading...</i></div>`;
      }

      function updateTextPlacement() {
        songInfoControls.classList.remove("hidden");
        songInfoOverlay.classList.add("hidden");
        const coverArtRect = coverArtContainer.getBoundingClientRect();
        const songInfoControlsRect = songInfoControls.getBoundingClientRect();
        if (coverArtRect.bottom > songInfoControlsRect.top + 10) {
          songInfoOverlay.classList.remove("hidden");
          songInfoControls.classList.add("hidden");
        }
      }

      function formatTime(totalSeconds) {
        if (isNaN(totalSeconds) || totalSeconds < 0) return "0:00";
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = Math.floor(totalSeconds % 60)
          .toString()
          .padStart(2, "0");
        return `${minutes}:${seconds}`;
      }

      function extractColors(imageElement) {
        try {
          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d", { willReadFrequently: true });
          canvas.width = imageElement.naturalWidth || 100;
          canvas.height = imageElement.naturalHeight || 100;
          ctx.drawImage(imageElement, 0, 0, canvas.width, canvas.height);
          const points = [
            [0.1, 0.2],
            [0.8, 0.1],
            [0.2, 0.8],
            [0.8, 0.8],
          ];
          const colors = points.map(([x, y]) => {
            const data = ctx.getImageData(
              x * canvas.width,
              y * canvas.height,
              1,
              1
            ).data;
            return `rgb(${data[0]}, ${data[1]}, ${data[2]})`;
          });
          document.documentElement.style.setProperty("--color-1", colors[0]);
          document.documentElement.style.setProperty("--color-2", colors[1]);
          document.documentElement.style.setProperty("--color-3", colors[2]);
          document.documentElement.style.setProperty("--color-4", colors[3]);
        } catch (e) {
          console.error("Color extraction failed.", e);
        }
      }

      function parseTimeToMilliseconds(timeStr) {
        const parts = timeStr.split(":");
        const secondsAndMs = parts[1].split(/[.:]/);
        const minutes = parseInt(parts[0], 10);
        const seconds = parseInt(secondsAndMs[0], 10);
        let milliseconds = parseInt(secondsAndMs[1], 10);
        if (secondsAndMs[1].length === 2) {
          milliseconds *= 10;
        }
        return (minutes * 60 + seconds) * 1000 + milliseconds;
      }

      function parseLRC(lrcText) {
        const MIN_TIME_TO_INSTRUM = 5000;

        const sanitizedText = lrcText.replace(/\\n/g, "\n").trim();
        const lines = sanitizedText
          .split("\n")
          .filter((line) => line.trim() !== "");
        const timedLines = [];
        const lineTimeRegex = /\[(\d{2}:\d{2}[.:]\d{2,3})\](.*)/;

        for (const line of lines) {
          const match = line.match(lineTimeRegex);
          if (match && match[2].trim() !== "") {
            timedLines.push({
              timeMs: parseTimeToMilliseconds(match[1]),
              text: match[2].trim(),
            });
          }
        }

        const parsedLines = timedLines.map((line, index) => {
          const nextLine = timedLines[index + 1];
          const endTime = nextLine ? nextLine.timeMs : line.timeMs + 30000;
          const isEnhanced = /<\d{2}:\d{2}[.:]\d{2,3}>/.test(line.text);
          let words = [];

          if (isEnhanced) {
            const splitRegex = /(<\d{2}:\d{2}[.:]\d{2,3}>)/g;
            const parts = line.text.split(splitRegex).filter(Boolean);

            let nextTime = null;
            let currentText = "";

            if (parts.length > 0 && !parts[0].startsWith("<")) {
              currentText = parts.shift().trim();
            }

            for (let i = 0; i < parts.length; i += 2) {
              const timeTag = parts[i];
              const wordText = (parts[i + 1] || "").trim();
              const currentTime = parseTimeToMilliseconds(
                timeTag.substring(1, timeTag.length - 1)
              );

              if (currentText) {
                words.push({
                  text: currentText,
                  start: nextTime !== null ? nextTime : line.timeMs,
                  end: currentTime,
                });
              }

              currentText = wordText;
              nextTime = currentTime;
            }

            if (currentText && nextTime !== null) {
              words.push({
                text: currentText,
                start: nextTime,
                end: endTime,
              });
            }
          } else {
            words = [{ text: line.text, start: line.timeMs, end: endTime }];
          }
          return { start: line.timeMs, end: endTime, words, isEnhanced };
        });

        if (parsedLines.length === 0) {
          return [];
        }

        const finalLyricsWithInstrumentals = [];
        const firstLine = parsedLines[0];
        if (firstLine.isEnhanced && firstLine.start >= MIN_TIME_TO_INSTRUM) {
          finalLyricsWithInstrumentals.push({
            start: 0,
            end: firstLine.start,
            type: "instrumental",
            words: [],
            isEnhanced: false,
          });
        }

        parsedLines.forEach((currentLine, i) => {
          finalLyricsWithInstrumentals.push(currentLine);
          const nextLine = parsedLines[i + 1];
          if (
            currentLine.isEnhanced &&
            currentLine.words.length > 0 &&
            nextLine
          ) {
            const lastWordOfCurrentLine =
              currentLine.words[currentLine.words.length - 1];
            const gap = nextLine.start - lastWordOfCurrentLine.end;

            if (gap >= MIN_TIME_TO_INSTRUM) {
              finalLyricsWithInstrumentals.push({
                start: lastWordOfCurrentLine.end,
                end: nextLine.start,
                type: "instrumental",
                words: [],
                isEnhanced: false,
              });
            }
          }
        });

        return finalLyricsWithInstrumentals;
      }

      function resetWordTransforms() {
        if (!lyrics || lyrics.length === 0) return;

        lyrics.forEach((line) => {
          if (line.words && line.isEnhanced) {
            line.words.forEach((word) => {
              if (word.dom) {
                const style = word.dom.style;
                style.backgroundPosition = "100% 0";

                style.textShadow = "";

                style.transform = "";

                style.animation = "";

                word.animationHasPlayed = false;
              }
            });
          }
        });
      }

      function initializeLyrics(parsedLyrics, allowSeeking) {
        lyricsContentWrapper.innerHTML = "";
        lyrics = parsedLyrics;
        currentLineIndex = -1;
        lastScrolledIndex = -1;

        const songHasEnhancedLyrics = parsedLyrics.some(
          (line) => line.isEnhanced
        );

        const topPad = document.createElement("div");
        topPad.style.height = `${lyricsViewport.clientHeight / 2}px`;
        lyricsContentWrapper.appendChild(topPad);

        lyrics.forEach((line, index) => {
          if (line.type === "instrumental") {
            if (songHasEnhancedLyrics) {
              const lineEl = document.createElement("div");
              lineEl.className = "line future instrumental-line";
              lineEl.innerHTML = '<i class="fa-solid fa-spinner-third"></i>';
              line.dom = lineEl;
              lyricsContentWrapper.appendChild(lineEl);
            }
            return;
          }

          const lineEl = document.createElement("div");
          lineEl.className = "line future";

          if (line.isEnhanced) {
            lineEl.classList.remove("line--simple");
            line.words.forEach((word) => {
              const wordEl = document.createElement("span");
              wordEl.className = "word";
              wordEl.innerHTML = word.text + "&nbsp;";
              word.dom = wordEl;
              word.animationHasPlayed = false;
              const MIN_DURATION_FOR_EFFECT = 2500;
              const wordDurationMs = word.end - word.start;
              if (wordDurationMs >= MIN_DURATION_FOR_EFFECT) {
                word.isLong = true;
                wordEl.style.setProperty(
                  "--word-duration",
                  `${wordDurationMs / 1000}s`
                );
              } else {
                word.isLong = false;
                wordEl.style.transition = "transform 2s ease-out";
              }
              lineEl.appendChild(wordEl);
            });
          } else {
            lineEl.classList.add("line--simple");
            const fullLineText = line.words.map((w) => w.text).join(" ");
            lineEl.textContent = fullLineText;
          }

          if (allowSeeking) {
            lineEl.style.cursor = "pointer";
            lineEl.addEventListener("click", () => {
              if (!player) return;
              if (isManuallyScrolling) resumeAutoScroll();
              resetWordTransforms();
              lastScrolledIndex = -1;
              playerInterface.youtube.seekTo(line.start / 1000);
            });
          }

          line.dom = lineEl;
          lyricsContentWrapper.appendChild(lineEl);
        });

        const bottomPad = document.createElement("div");
        bottomPad.style.height = `${lyricsViewport.clientHeight / 2}px`;
        lyricsContentWrapper.appendChild(bottomPad);

        resetWordTransforms();
        unifiedLyricsUpdater(-1);
      }

      async function performSearch(query) {
  showLoader(searchResultsContainer);
  searchDetailsView.innerHTML = "";

  try {
    const encodedQuery = encodeURIComponent(`q=${query}`);

    const artistPromise = fetch(
      `https://vapor.my/api/mxsearch?path=searchArtist&queries=${encodedQuery}`
    ).then(res => res.json());

    const albumPromise = fetch(
      `https://vapor.my/api/mxsearch?path=searchAlbum&queries=${encodedQuery}`
    ).then(res => res.json());

    const trackPromise = fetch(
      `https://vapor.my/api/mxsearch?path=searchTrack&queries=${encodedQuery}${encodeURIComponent('&limit=25')}`
    ).then(res => res.json());

    const results = await Promise.allSettled([
      artistPromise,
      albumPromise,
      trackPromise,
    ]);

    const artistData = results[0].status === "fulfilled" ? results[0].value : null;
    const albumData = results[1].status === "fulfilled" ? results[1].value : null;
    const trackData = results[2].status === "fulfilled" ? results[2].value : null;

    if (artistData?.error || albumData?.error || trackData?.error) {
        throw new Error('One or more search queries failed');
    }

    searchResultsContainer.innerHTML = "";
    const fragment = document.createDocumentFragment();

    const firstArtist = artistData?.data?.[0];
    const firstAlbum = albumData?.data?.[0];
    const tracks = (trackData?.data || []).sort((a, b) => b.rank - a.rank);
    const firstTrack = tracks[0];

    let resultsFound = false;

    const isExactArtistMatch =
      firstArtist &&
      firstArtist.name.toLowerCase() === query.toLowerCase();
    const isObscureArtist = firstArtist && firstArtist.nb_fan < 5000;
    const isPopularTrack = firstTrack && firstTrack.rank > 500000;

    const trackQueue = tracks.slice(0, 15).map((t) => ({
      trackName: t.title,
      artistName: t.artist.name,
      artworkUrl100: t.album.cover_medium,
      artworkUrl1000: t.album.cover_xl,
      trackId: t.id,
      artistId: t.artist.id,
    }));

    if (isExactArtistMatch && !(isObscureArtist && isPopularTrack)) {
      if (GROUP_RESULTS) fragment.appendChild(createSectionHeader("Top Result"));
      fragment.appendChild(createArtistResultItem(firstArtist, searchDetailsView));
      if (GROUP_RESULTS) fragment.appendChild(createSectionHeader("Songs"));
      tracks
        .slice(0, 10)
        .forEach((track, index) =>
          fragment.appendChild(createTrackResultItem(track, trackQueue, index))
        );
      resultsFound = true;
    } else if (
      firstAlbum &&
      firstAlbum.title.toLowerCase().includes(query.toLowerCase())
    ) {
      if (GROUP_RESULTS) fragment.appendChild(createSectionHeader("Top Result"));
      fragment.appendChild(createAlbumResultItem(firstAlbum));
      if (GROUP_RESULTS) fragment.appendChild(createSectionHeader("Songs"));
      tracks
        .slice(0, 10)
        .forEach((track, index) =>
          fragment.appendChild(createTrackResultItem(track, trackQueue, index))
        );
      resultsFound = true;
    } else if (tracks.length > 0) {
      if (GROUP_RESULTS) fragment.appendChild(createSectionHeader("Songs"));
      tracks
        .slice(0, 15)
        .forEach((track, index) =>
          fragment.appendChild(createTrackResultItem(track, trackQueue, index))
        );
      resultsFound = true;
    }

    if (!resultsFound) {
      searchResultsContainer.innerHTML = `<div class="line" style="font-size: 1.2em; text-align: center; opacity: 1; filter: none;">No results found.</div>`;
    } else {
      searchResultsContainer.appendChild(fragment);
    }
  } catch (error) {
    console.error("Backend search failed:", error);
    searchResultsContainer.innerHTML = `<div class="line" style="font-size: 1.2em; text-align: center; opacity: 1; filter: none;">Search failed. Please try again.</div>`;
  }
}

      function createTrackResultItem(track, queue = [], index = -1) {
        const item = document.createElement("div");
        item.className = "result-item";
        const cover = track.album?.cover_medium || track.artworkUrl100;
        item.innerHTML = `<img src="${cover}" alt="${
          track.title || track.trackName
        }"><div class="result-text"><h3>${
          track.title || track.trackName
        }</h3><p>${track.artist?.name || track.artistName}</p></div>`;
        item.addEventListener("click", () => {
          const trackDataForPlayer = {
            trackName: track.title || track.trackName,
            artistName: track.artist?.name || track.artistName,
            artworkUrl100: track.album?.cover_medium || track.artworkUrl100,
            artworkUrl1000: track.album?.cover_xl || track.artworkUrl1000,
            trackId: track.id,
            artistId: track.artist?.id || track.artistId,
          };
          loadTrack(trackDataForPlayer, queue, index);
        });
        return item;
      }

      function createArtistResultItem(artist, targetContainer) {
        const item = document.createElement("div");
        item.className = "result-item";
        item.innerHTML = `<img src="${artist.picture_medium}" alt="${artist.name}"><div class="result-text"><h3>${artist.name}</h3><p>Artist</p></div>`;
        item.addEventListener("click", () =>
          displayArtistDetails(artist, targetContainer)
        );
        return item;
      }

      function createAlbumResultItem(album, artistContext) {
        const item = document.createElement("div");
        item.className = "result-item";
        const artistName = album.artist?.name || artistContext?.name || "";
        item.innerHTML = `<img src="${album.cover_medium}" alt="${album.title}"><div class="result-text"><h3>${album.title}</h3><p>${artistName}</p></div>`;

        const albumObjectForClick = { ...album };
        if (!albumObjectForClick.artist && artistContext) {
          albumObjectForClick.artist = artistContext;
        }
        item.addEventListener("click", () =>
          displayAlbumDetails(albumObjectForClick)
        );
        return item;
      }

      async function displayArtistDetails(artist, targetContainer) {
        showLoader(targetContainer);
        try {
          const topTracksPromise = fetch(
            `https://vapor.my/api/mxsearch?path=artist${
              artist.id
            }Top&queries=${encodeURIComponent("limit=10")}`
          ).then((res) => res.json());

          const albumsPromise = fetch(
            `https://vapor.my/api/mxsearch?path=artist${
              artist.id
            }Albums&queries=${encodeURIComponent("limit=10")}`
          ).then((res) => res.json());

          const results = await Promise.allSettled([
            topTracksPromise,
            albumsPromise,
          ]);

          const topTracksResult = results[0];
          const albumsResult = results[1];

          const topTracksData =
            topTracksResult.status === "fulfilled"
              ? topTracksResult.value
              : null;
          const albumsData =
            albumsResult.status === "fulfilled" ? albumsResult.value : null;

          targetContainer.innerHTML = "";
          const fragment = document.createDocumentFragment();

          const header = document.createElement("div");
          header.className = "details-header";
          header.innerHTML = `
      <img src="${artist.picture_big}" alt="${artist.name}">
      <div class="details-header-text">
          <h2>${artist.name}</h2>
          <p>${artist.nb_fan.toLocaleString()} fans</p>
      </div>
    `;
          fragment.appendChild(header);

          const trackQueue = (topTracksData?.data || []).map((t) => ({
            trackName: t.title,
            artistName: t.artist.name,
            artworkUrl100: t.album.cover_medium,
            artworkUrl1000: t.album.cover_xl,
            trackId: t.id,
            artistId: t.artist.id,
          }));

          if (topTracksData?.data?.length > 0) {
            fragment.appendChild(createSectionHeader("Top Tracks", true));
            topTracksData.data.forEach((track, index) =>
              fragment.appendChild(
                createTrackResultItem(track, trackQueue, index)
              )
            );
          }

          if (albumsData?.data?.length > 0) {
            fragment.appendChild(createSectionHeader("Albums", true));
            albumsData.data.forEach((album) =>
              fragment.appendChild(createAlbumResultItem(album, artist))
            );
          }

          targetContainer.appendChild(fragment);
        } catch (e) {
          console.error("Failed to load artist details:", e);
          targetContainer.innerHTML = `<div class="line" style="font-size: 1.2em; text-align: center; opacity: 1; filter: none;">Could not load artist details.</div>`;
        }
      }

      async function displayAlbumDetails(album) {
        showLoader(searchDetailsView);
        try {
          const response = await fetch(
            `https://vapor.my/api/mxsearch?path=album${album.id}`
          );
          const fullAlbumData = await response.json();

          if (!response.ok || fullAlbumData.error) {
            throw new Error(fullAlbumData.error || "Could not load album");
          }

          searchDetailsView.innerHTML = "";
          const fragment = document.createDocumentFragment();

          const header = document.createElement("div");
          header.className = "details-header";
          header.innerHTML = `
      <img src="${fullAlbumData.cover_big}" alt="${fullAlbumData.title}">
      <div class="details-header-text">
          <h2>${fullAlbumData.title}</h2>
          <p>${
            fullAlbumData.artist.name
          }  ${fullAlbumData.release_date.substring(0, 4)}</p>
      </div>
    `;
          fragment.appendChild(header);

          const trackQueue = (fullAlbumData.tracks.data || []).map((t) => ({
            trackName: t.title,
            artistName: fullAlbumData.artist.name,
            artworkUrl100: fullAlbumData.cover_medium,
            artworkUrl1000: fullAlbumData.cover_xl,
            trackId: t.id,
            artistId: fullAlbumData.artist.id,
          }));

          if (
            fullAlbumData.tracks.data &&
            fullAlbumData.tracks.data.length > 0
          ) {
            fragment.appendChild(createSectionHeader("Tracklist", true));
            fullAlbumData.tracks.data.forEach((track, index) => {
              const enrichedTrack = {
                ...track,
                artist: {
                  name: fullAlbumData.artist.name,
                  id: fullAlbumData.artist.id,
                },
                album: {
                  cover_medium: fullAlbumData.cover_medium,
                  cover_xl: fullAlbumData.cover_xl,
                },
              };
              fragment.appendChild(
                createTrackResultItem(enrichedTrack, trackQueue, index)
              );
            });
          }

          searchDetailsView.appendChild(fragment);
        } catch (e) {
          console.error("Failed to load album details:", e);
          searchDetailsView.innerHTML = `<div class="line" style="font-size: 1.2em; text-align: center; opacity: 1; filter: none;">Could not load album details.</div>`;
        }
      }

      function createSectionHeader(title, isDetailsView = false) {
        const h4 = document.createElement("h4");
        h4.className = isDetailsView
          ? "details-section-title"
          : "result-section-header";
        h4.textContent = title;
        return h4;
      }

      function handleSliderInteraction(container, fillElement, callback) {
        let isDragging = false;
        const handler = (event) => {
          if (container.classList.contains("disabled")) return;
          const rect = container.getBoundingClientRect();
          const x =
            (event.touches ? event.touches[0].clientX : event.clientX) -
            rect.left;
          const percentage = Math.max(0, Math.min(1, x / rect.width));
          fillElement.style.width = `${percentage * 100}%`;
          callback(percentage, isDragging);
        };
        container.addEventListener("mousedown", (e) => {
          isDragging = true;
          handler(e);
        });
        document.addEventListener("mousemove", (e) => {
          if (isDragging) handler(e);
        });
        document.addEventListener("mouseup", () => (isDragging = false));
        container.addEventListener("click", (e) => handler(e));
      }

      handleSliderInteraction(
        scrubBarContainer,
        scrubBarFill,
        (percentage, isDragging) => {
          if (!player) return;
          if (isDragging) {
            lastScrolledIndex = -1;
            resetWordTransforms();
            const duration = playerInterface.youtube.getDuration();
            if (duration) playerInterface.youtube.seekTo(percentage * duration);
          }
        }
      );

      handleSliderInteraction(
        volumeBarContainer,
        volumeBarFill,
        (percentage) => {
          if (player) playerInterface.youtube.setVolume(percentage);
        }
      );

      function getFavorites() {
        return JSON.parse(localStorage.getItem("favorites")) || [];
      }
      function saveFavorites(favorites) {
        localStorage.setItem("favorites", JSON.stringify(favorites));
      }
      function toggleFavorite() {
        if (!currentTrackData) return;
        let favorites = getFavorites();
        const existingIndex = favorites.findIndex(
          (fav) => fav.trackId === currentTrackData.trackId
        );
        if (existingIndex > -1) {
          favorites.splice(existingIndex, 1);
        } else {
          const trackToSave = { ...currentTrackData };
          if (currentRawLRC) {
            trackToSave.rawLRC = currentRawLRC;
          }
          favorites.push(trackToSave);
        }
        saveFavorites(favorites);
        updateFavoriteButtonState();
        displayFavorites();
      }
      function updateFavoriteButtonState() {
        if (!currentTrackData) return;
        const isFavorited = getFavorites().some(
          (fav) => fav.trackId === currentTrackData.trackId
        );
        favoriteButton.classList.toggle("favorited", isFavorited);
        const icon = favoriteButton.querySelector("i");
        icon.classList.toggle("fa-solid", isFavorited);
        icon.classList.toggle("fa-regular", !isFavorited);
      }

      function removeFromFavorites(trackIdToRemove) {
        let favorites = getFavorites();
        favorites = favorites.filter((fav) => fav.trackId !== trackIdToRemove);
        saveFavorites(favorites);
        displayFavorites(playlistSearchInput.value.trim());
        updateFavoriteButtonState();
      }

      function displayFavorites(filter = "") {
        const favorites = getFavorites();
        playlistResultsContainer.innerHTML = "";
        const filteredFavorites = favorites.filter(
          (fav) =>
            fav.trackName.toLowerCase().includes(filter.toLowerCase()) ||
            fav.artistName.toLowerCase().includes(filter.toLowerCase())
        );

        const favQueue = filteredFavorites.map((t) => ({ ...t }));

        if (filteredFavorites.length > 0) {
          filteredFavorites.forEach((track, index) => {
            const item = document.createElement("div");
            item.className = "result-item";
            item.dataset.id = track.trackId;

            const contentWrapper = document.createElement("div");
            contentWrapper.style.display = "flex";
            contentWrapper.style.alignItems = "center";
            contentWrapper.style.gap = "15px";
            contentWrapper.style.flexGrow = "1";
            contentWrapper.style.minWidth = "0";
            contentWrapper.innerHTML = `<img src="${(
              track.artworkUrl1000 || track.artworkUrl100
            ).replace("100x100", "120x120")}" alt="${
              track.trackName
            }"><div class="result-text"><h3>${track.trackName}</h3><p>${
              track.artistName
            }</p></div>`;
            contentWrapper.addEventListener("click", () =>
              loadTrack(track, favQueue, index)
            );

            const removeBtn = document.createElement("button");
            removeBtn.className = "remove-favorite-btn";
            removeBtn.title = "Remove from favorites";
            removeBtn.innerHTML = '<i class="fa-solid fa-xmark"></i>';
            removeBtn.addEventListener("click", (e) => {
              e.stopPropagation();
              removeFromFavorites(track.trackId);
            });

            item.appendChild(contentWrapper);
            item.appendChild(removeBtn);
            playlistResultsContainer.appendChild(item);
          });

          new Sortable(playlistResultsContainer, {
            animation: 150,
            ghostClass: "sortable-ghost",
            delay: 200,
            delayOnTouchOnly: true,
            onEnd: (evt) => {
              const newOrderIds = Array.from(evt.to.children).map((el) =>
                String(el.dataset.id)
              );
              let favorites = getFavorites();
              const favoriteMap = new Map(
                favorites.map((f) => [String(f.trackId), f])
              );
              const reorderedFavorites = newOrderIds
                .map((id) => favoriteMap.get(id))
                .filter(Boolean);
              saveFavorites(reorderedFavorites);
            },
          });
        } else {
          playlistResultsContainer.innerHTML = `<div class="line" style="font-size: 1.2em; text-align: center; opacity: 1; filter: none;">${
            favorites.length === 0
              ? "No favorites yet. Try clicking <i class='fa-solid fa-star'></i> while playing a song."
              : "No matching favorites."
          }</div>`;
        }
      }

      function resetMarquees() {
        activeMarquees.forEach(({ element, timeout, listener, wrapper }) => {
          clearTimeout(timeout);
          wrapper.removeEventListener("animationiteration", listener);
          const originalText = element.getAttribute("data-original-text");
          if (originalText) {
            element.innerHTML = "";
            element.textContent = originalText;
          }
          element.classList.remove("is-overflowing", "is-scrolling");
          element.removeAttribute("data-original-text");
          element.style.cssText = "";
        });
        activeMarquees = [];
      }

      function applyMarquee(element) {
        if (element.scrollWidth <= element.clientWidth) return;
        const originalText = element.textContent;
        element.setAttribute("data-original-text", originalText);
        element.innerHTML = `<div class="marquee-wrapper"><span class="marquee-content">${originalText}</span><span class="marquee-content">${originalText}</span></div>`;
        element.classList.add("is-overflowing");
        const wrapper = element.querySelector(".marquee-wrapper");
        const duration =
          wrapper.querySelector(".marquee-content").offsetWidth / 40;
        element.style.setProperty("--duration", `${duration}s`);
        let scrollTimeout;
        const animationListener = () => {
          wrapper.style.animationPlayState = "paused";
          element.classList.remove("is-scrolling");
          clearTimeout(scrollTimeout);
          scrollTimeout = setTimeout(() => {
            wrapper.style.animationPlayState = "running";
            element.classList.add("is-scrolling");
          }, 3000);
        };
        wrapper.addEventListener("animationiteration", animationListener);
        scrollTimeout = setTimeout(() => {
          wrapper.style.animationPlayState = "running";
          element.classList.add("is-scrolling");
        }, 3000);
        activeMarquees.push({
          element,
          timeout: scrollTimeout,
          listener: animationListener,
          wrapper,
        });
      }

      function setupMarquees() {
        resetMarquees();
        [...allSongTitles, ...allArtistNames].forEach((element) => {
          if (
            element.clientWidth > 0 &&
            element.textContent &&
            element.textContent !== "Not Playing"
          ) {
            applyMarquee(element);
          }
        });
      }

      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      function handleManualScrollStart() {
        isManuallyScrolling = true;
        lyricsContentWrapper.classList.add("manual-scroll");
        clearTimeout(scrollTimeout);
      }

      function resumeAutoScroll() {
        isManuallyScrolling = false;
        lyricsContentWrapper.classList.remove("manual-scroll");
        lastScrolledIndex = -1;
      }

      function handleManualScrollEnd() {
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(resumeAutoScroll, 2500);
      }

      function mergeBuffers(bufferArray, totalLength) {
        const result = new Float32Array(totalLength);
        let offset = 0;
        for (const buffer of bufferArray) {
          result.set(buffer, offset);
          offset += buffer.length;
        }
        return result;
      }

      function arrayBufferToBase64(buffer) {
        let binary = "";
        const bytes = new Uint8Array(buffer);
        for (let i = 0; i < bytes.byteLength; i++)
          binary += String.fromCharCode(bytes[i]);
        return window.btoa(binary);
      }

      function generateUUID() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
          var r = (Math.random() * 16) | 0,
            v = c == "x" ? r : (r & 0x3) | 0x8;
          return v.toString(16);
        });
      }

      function updateQueueControls() {
        const hasQueue = playbackQueue.length > 1;
        nextTrackButton.classList.toggle("hidden", !hasQueue);
        prevTrackButton.classList.toggle("hidden", !hasQueue);
        nextTrackButton.disabled =
          queueIndex >= playbackQueue.length - 1 && !isRepeating;
        prevTrackButton.disabled = queueIndex <= 0;
      }

      function handleRecognizeButtonClick() {
        if (mainScreen.classList.contains("recognized-mode"))
          resetToInitialState();
        else if (!isRecognizing) startRecognition();
      }

      function updateRecommendationsPanel() {
        recommendationsMenu.innerHTML = "";
        if (isRadioActive) {
          recommendationsDetailsView.innerHTML = `
                <div class="radio-active-view">
                  <h2>Radio Mode is Active</h2>
                  <p>Playing endless music like ${radioSeedArtist}.</p>
                  <button class="stop-radio-button" id="stop-radio-button">Stop Radio</button>
                </div>
            `;
          document
            .getElementById("stop-radio-button")
            .addEventListener("click", () => stopRadioMode(true));
        } else {
          recommendationsDetailsView.innerHTML = "";
        }

        const favorites = getFavorites();
        const fragment = document.createDocumentFragment();

        const radioItem = document.createElement("div");
        radioItem.className = "recommendations-menu-item";
        if (!currentTrackData || isRadioActive)
          radioItem.classList.add("disabled");
        radioItem.innerHTML = `<div class="icon"><i class="fa-solid fa-tower-broadcast"></i></div><div class="text-content"><h3>Start Radio</h3><p>Endless music based on the playing artist.</p></div>`;
        radioItem.addEventListener("click", () =>
          startRadioMode(currentTrackData, true)
        );
        fragment.appendChild(radioItem);

        const discoverItem = document.createElement("div");
        discoverItem.className = "recommendations-menu-item";
        const canDiscover = favorites.length >= 5;
        if (!canDiscover) {
          discoverItem.classList.add("disabled");
          discoverItem.title = "Favorite at least 5 songs to unlock.";
        }
        discoverItem.innerHTML = `<div class="icon"><i class="fa-solid fa-compass"></i></div><div class="text-content"><h3>Daily Discover</h3><p>A daily playlist similar to your favorites.</p></div>`;
        discoverItem.addEventListener("click", () =>
          generateDailyDiscover(false)
        );
        fragment.appendChild(discoverItem);

        if (currentTrackData) {
          const contextHeader = document.createElement("div");
          contextHeader.className = "recommendations-context-header";
          contextHeader.textContent = `More like "${currentTrackData.trackName}"`;
          fragment.appendChild(contextHeader);

          const similarSongsItem = document.createElement("div");
          similarSongsItem.className = "recommendations-menu-item";
          similarSongsItem.innerHTML = `<div class="icon"><i class="fa-solid fa-music"></i></div><div class="text-content"><h3>Similar Songs</h3><p>A playlist of tracks with a similar vibe.</p></div>`;
          similarSongsItem.addEventListener("click", () =>
            generateSimilarSongs(currentTrackData)
          );
          fragment.appendChild(similarSongsItem);

          const similarArtistsItem = document.createElement("div");
          similarArtistsItem.className = "recommendations-menu-item";
          similarArtistsItem.innerHTML = `<div class="icon"><i class="fa-solid fa-users"></i></div><div class="text-content"><h3>Similar Artists</h3><p>Explore artists with a sound like this one.</p></div>`;
          similarArtistsItem.addEventListener("click", () =>
            generateSimilarArtists(currentTrackData)
          );
          fragment.appendChild(similarArtistsItem);
        }

        recommendationsMenu.appendChild(fragment);
      }

      async function showCuratingLoader() {
        recommendationsDetailsView.innerHTML = `<div class="curating-text"><i>Curating...</i></div>`;
        return new Promise((resolve) =>
          setTimeout(resolve, 1500 + Math.random() * 600)
        );
      }

      async function generateSimilarSongs(trackData) {
        if (!trackData) return;
        const loadingPromise = showCuratingLoader();
        try {
          const artistId =
            trackData.artistId ||
            (
              await fetch(
                `https://vapor.my/api/mxsearch?path=searchArtist&queries=${encodeURIComponent(
                  `q=${trackData.artistName}`
                )}`
              ).then((r) => r.json())
            ).data[0]?.id;
          if (!artistId) throw new Error("Artist not found");

          const radioData = await fetch(
            `https://vapor.my/api/mxrecommend?path=artist${artistId}Radio`
          ).then((r) => r.json());
          if (radioData.error) throw new Error(radioData.error);

          const trackQueue = radioData.data.map((track) => ({
            trackName: track.title,
            artistName: track.artist.name,
            artworkUrl100: track.album.cover_medium,
            artworkUrl1000: track.album.cover_xl,
            trackId: track.id,
            artistId: track.artist.id,
          }));

          await loadingPromise;
          recommendationsDetailsView.innerHTML = "";
          trackQueue.forEach((track, index) => {
            recommendationsDetailsView.appendChild(
              createTrackResultItem(track, trackQueue, index)
            );
          });
        } catch (error) {
          console.error("Failed to generate similar songs:", error);
          await loadingPromise;
          recommendationsDetailsView.innerHTML = `<div class="no-lyrics-message">Could not generate recommendations.</div>`;
        }
      }
      async function generateSimilarArtists(trackData) {
        if (!trackData) return;
        const loadingPromise = showCuratingLoader();
        try {
          const artistId =
            trackData.artistId ||
            (
              await fetch(
                `https://vapor.my/api/mxsearch?path=searchArtist&queries=${encodeURIComponent(
                  `q=${trackData.artistName}`
                )}`
              ).then((r) => r.json())
            ).data[0]?.id;
          if (!artistId) throw new Error("Artist not found");

          const relatedData = await fetch(
            `https://vapor.my/api/mxrecommend?path=artist${artistId}Related`
          ).then((r) => r.json());
          if (relatedData.error) throw new Error(relatedData.error);

          await loadingPromise;
          recommendationsDetailsView.innerHTML = "";
          relatedData.data.forEach((artist) => {
            recommendationsDetailsView.appendChild(
              createArtistResultItem(artist, recommendationsDetailsView)
            );
          });
        } catch (error) {
          console.error("Failed to generate similar artists:", error);
          await loadingPromise;
          recommendationsDetailsView.innerHTML = `<div class="no-lyrics-message">Couldn't find similar artists.</div>`;
        }
      }

      function displayDailyDiscover(tracks) {
        recommendationsDetailsView.innerHTML = "";
        const fragment = document.createDocumentFragment();

        const header = document.createElement("div");
        header.className = "daily-discover-header";
        header.innerHTML = `<h4>Resets every midnight</h4> <button class="refresh-discover-button">Generate More</button>`;
        header
          .querySelector("button")
          .addEventListener("click", () => generateDailyDiscover(true));
        fragment.appendChild(header);

        tracks.forEach((track, index) => {
          fragment.appendChild(createTrackResultItem(track, tracks, index));
        });
        recommendationsDetailsView.appendChild(fragment);
      }

      async function generateDailyDiscover(forceRefresh = false) {
        const today = new Date().toDateString();
        const cache = JSON.parse(localStorage.getItem("dailyDiscoverCache"));

        if (!forceRefresh && cache && cache.date === today) {
          console.log("Loading Daily Discover from cache.");
          displayDailyDiscover(cache.tracks);
          return;
        }

        const loadingPromise = showCuratingLoader();
        try {
          const favorites = getFavorites();
          if (favorites.length < 5) {
            await loadingPromise;
            recommendationsDetailsView.innerHTML = `<div class="no-lyrics-message">Favorite at least 5 songs to unlock this feature.</div>`;
            return;
          }

          let artistIds = [
            ...new Set(favorites.map((fav) => fav.artistId).filter(Boolean)),
          ];
          if (artistIds.length < 3) {
            for (const fav of favorites) {
              if (artistIds.length >= 5) break;
              try {
                const search = await fetch(
                  `https://vapor.my/api/mxsearch?path=searchArtist&queries=${encodeURIComponent(
                    `q=${fav.artistName}`
                  )}`
                ).then((r) => r.json());
                if (search.data[0] && !artistIds.includes(search.data[0].id))
                  artistIds.push(search.data[0].id);
              } catch (e) {
                console.warn("Could not find artist ID for", fav.artistName);
              }
            }
          }

          const seedArtists = [...new Set(artistIds)]
            .sort(() => 0.5 - Math.random())
            .slice(0, 5);

          const relatedPromises = seedArtists.map((id) =>
            fetch(
              `https://vapor.my/api/mxrecommend?path=artist${id}Related`
            ).then((r) => r.json())
          );
          const relatedResults = await Promise.all(relatedPromises);

          const relatedArtistPool = [
            ...new Set(
              relatedResults.flatMap((res) =>
                (res.data || []).map((artist) => artist.id)
              )
            ),
          ];
          const finalArtists = relatedArtistPool
            .sort(() => 0.5 - Math.random())
            .slice(0, 10);

          const topTrackPromises = finalArtists.map((id) =>
            fetch(
              `https://vapor.my/api/mxsearch?path=artist${id}Top&queries=${encodeURIComponent(
                "limit=2"
              )}`
            ).then((r) => r.json())
          );
          const topTrackResults = await Promise.all(topTrackPromises);

          let trackQueue = topTrackResults
            .flatMap((res) => res.data || [])
            .map((track) => ({
              trackName: track.title,
              artistName: track.artist.name,
              artworkUrl100: track.album.cover_medium,
              artworkUrl1000: track.album.cover_xl,
              trackId: track.id,
              artistId: track.artist.id,
            }));
          trackQueue = trackQueue.sort(() => 0.5 - Math.random());

          localStorage.setItem(
            "dailyDiscoverCache",
            JSON.stringify({ date: today, tracks: trackQueue })
          );

          await loadingPromise;
          displayDailyDiscover(trackQueue);
        } catch (error) {
          console.error("Failed to generate Daily Discover:", error);
          await loadingPromise;
          recommendationsDetailsView.innerHTML = `<div class="no-lyrics-message">Could not generate discovery playlist.</div>`;
        }
      }

      async function startRadioMode(trackData, playImmediately = true) {
        if (!trackData) return;

        mainScreen.classList.remove("recommendations-active", "panel-active");

        try {
          const artistId =
            trackData.artistId ||
            (
              await fetch(
                `https://vapor.my/api/mxsearch?path=searchArtist&queries=${encodeURIComponent(
                  `q=${trackData.artistName}`
                )}`
              ).then((r) => r.json())
            ).data[0]?.id;
          if (!artistId) throw new Error("Artist not found");

          radioSeedArtist = trackData.artistName;

          const radioData = await fetch(
            `https://vapor.my/api/mxrecommend?path=artist${artistId}Radio`
          ).then((r) => r.json());
          if (radioData.error) throw new Error(radioData.error);

          const radioQueue = radioData.data.map((track) => ({
            trackName: track.title,
            artistName: track.artist.name,
            artworkUrl100: track.album.cover_medium,
            artworkUrl1000: track.album.cover_xl,
            trackId: track.id,
            artistId: track.artist.id,
          }));

          isRadioActive = true;
          recommendationsOpenButton.classList.add("radio-active");
          recommendationsOpenButton
            .querySelector("i")
            .classList.replace("fa-wand-magic-sparkles", "fa-tower-broadcast");

          if (playImmediately) {
            playbackQueue = radioQueue;
            queueIndex = -1;
            playNextTrack();
          } else {
            playbackQueue.push(...radioQueue);
            updateQueueControls();
          }
        } catch (error) {
          console.error("Failed to start radio:", error);
          stopRadioMode(false);
        }
      }

      function stopRadioMode(closePanel = true) {
        isRadioActive = false;
        radioSeedArtist = null;
        playbackQueue.splice(queueIndex + 1);
        updateQueueControls();
        recommendationsOpenButton.classList.remove("radio-active");
        recommendationsOpenButton
          .querySelector("i")
          .classList.replace("fa-tower-broadcast", "fa-wand-magic-sparkles");
        if (closePanel) {
          mainScreen.classList.remove("recommendations-active", "panel-active");
        }
      }

playPauseButton.addEventListener("click", () => {
  if (!player || typeof player.getPlayerState !== "function") {
    return;
  }

  const playerState = player.getPlayerState();

  if (playerState === YT.PlayerState.PLAYING) {
    player.pauseVideo();
  } else {
    player.playVideo();
  }
});
      repeatButton.addEventListener("click", () => {
        isRepeating = !isRepeating;
        repeatButton.classList.toggle("active", isRepeating);
        updateQueueControls();
      });
      favoriteButton.addEventListener("click", toggleFavorite);
      recognizeButton.addEventListener("click", handleRecognizeButtonClick);

      nextTrackButton.addEventListener("click", playNextTrack);
      prevTrackButton.addEventListener("click", () => {
        if (playbackQueue.length > 0 && queueIndex > 0) {
          queueIndex--;
          loadTrack(playbackQueue[queueIndex], playbackQueue, queueIndex);
        }
      });

      lyricsViewport.addEventListener(
        "wheel",
        (e) => {
          e.preventDefault();
          handleManualScrollStart();
          const currentOffset = parseFloat(
            getComputedStyle(document.documentElement).getPropertyValue(
              "--lyrics-offset"
            )
          );
          document.documentElement.style.setProperty(
            "--lyrics-offset",
            `${currentOffset - e.deltaY}px`
          );
          handleManualScrollEnd();
        },
        { passive: false }
      );

      lyricsViewport.addEventListener(
        "touchstart",
        (e) => {
          handleManualScrollStart();
          touchStartY = e.touches[0].clientY;
          initialTouchOffset = parseFloat(
            getComputedStyle(document.documentElement).getPropertyValue(
              "--lyrics-offset"
            )
          );
        },
        { passive: true }
      );

      lyricsViewport.addEventListener(
        "touchmove",
        (e) => {
          if (!isManuallyScrolling) return;
          e.preventDefault();
          const touchCurrentY = e.touches[0].clientY;
          const deltaY = touchCurrentY - touchStartY;
          document.documentElement.style.setProperty(
            "--lyrics-offset",
            `${initialTouchOffset + deltaY}px`
          );
        },
        { passive: false }
      );

      lyricsViewport.addEventListener("touchend", handleManualScrollEnd);

      viewToggleButton.addEventListener("click", () => {
        mainScreen.classList.toggle("lyrics-visible");
        const isLyrics = mainScreen.classList.contains("lyrics-visible");
        viewToggleIcon.classList.toggle("fa-music", !isLyrics);
        viewToggleIcon.classList.toggle("fa-image", isLyrics);
      });
      searchOpenButton.addEventListener("click", () => {
        mainScreen.classList.add("panel-active", "search-active");
        searchInput.focus();
      });
      searchCloseButton.addEventListener("click", () => {
        mainScreen.classList.remove("panel-active", "search-active");
        searchInput.value = "";
        searchResultsContainer.innerHTML = "";
        searchDetailsView.innerHTML = "";
      });
      playlistButton.addEventListener("click", () => {
        displayFavorites();
        mainScreen.classList.add("panel-active", "playlist-active");
        playlistSearchInput.focus();
      });
      playlistCloseButton.addEventListener("click", () => {
        mainScreen.classList.remove("panel-active", "playlist-active");
        playlistSearchInput.value = "";
      });
      recommendationsOpenButton.addEventListener("click", () => {
        updateRecommendationsPanel();
        mainScreen.classList.add("panel-active", "recommendations-active");
      });
      recommendationsCloseButton.addEventListener("click", () => {
        mainScreen.classList.remove("panel-active", "recommendations-active");
      });
      searchInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && searchInput.value.trim())
          performSearch(searchInput.value.trim());
      });
      playlistSearchInput.addEventListener("input", () =>
        displayFavorites(playlistSearchInput.value.trim())
      );

      const debouncedSetupMarquees = debounce(setupMarquees, 250);
      window.addEventListener("resize", () => {
        updateTextPlacement();
        debouncedSetupMarquees();
      });

      document.addEventListener("visibilitychange", () => {
        if (!document.hidden) {
          if ((isPlaying && player) || isRecognitionSyncActive) {
            lyricsContentWrapper.classList.add("no-transition");

            const currentTimeMs = isRecognitionSyncActive
              ? Date.now() - songStartTime
              : playerInterface.youtube.getCurrentTime() * 1000;

            unifiedLyricsUpdater(currentTimeMs);

            requestAnimationFrame(() => {
              lyricsContentWrapper.classList.remove("no-transition");
            });
          }
        }
      });

      document.addEventListener("DOMContentLoaded", () => {
        mainScreen.classList.add("initial-state");
        lyricsContentWrapper.innerHTML = "";
        updateTextPlacement();

        if (typeof YT !== "undefined" && YT.Player) {
          console.log("API was already ready, manually initializing player.");
          initializePlayer();
        }
      });

      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          if (mainScreen.classList.contains("search-active")) {
            searchCloseButton.click();
            return;
          }
          if (mainScreen.classList.contains("playlist-active")) {
            playlistCloseButton.click();
            return;
          }
          if (mainScreen.classList.contains("recommendations-active")) {
            recommendationsCloseButton.click();
            return;
          }
        }

        if (document.activeElement.tagName === "INPUT") {
          return;
        }

        const canControlPlayer = player && isPlayerReady;

        switch (e.code) {
          case "KeyK":
            if (canControlPlayer) playPauseButton.click();
            break;

          case "ArrowLeft":
            if (canControlPlayer)
              playerInterface.youtube.seekTo(player.getCurrentTime() - 5);
            break;
          case "ArrowRight":
            if (canControlPlayer)
              playerInterface.youtube.seekTo(player.getCurrentTime() + 5);
            break;
          case "KeyJ":
            if (canControlPlayer)
              playerInterface.youtube.seekTo(player.getCurrentTime() - 10);
            break;
          case "KeyL":
            if (canControlPlayer)
              playerInterface.youtube.seekTo(player.getCurrentTime() + 10);
            break;

          case "Comma":
            if (canControlPlayer && !prevTrackButton.disabled)
              prevTrackButton.click();
            break;
          case "Period":
            if (canControlPlayer && !nextTrackButton.disabled)
              nextTrackButton.click();
            break;

          case "KeyR":
            repeatButton.click();
            break;
        }
      });
    </script>
    <script src="https://www.youtube.com/iframe_api"></script>
  </body>
</html>
